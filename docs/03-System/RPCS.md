# Remote Procedure Calls (RPCs)

## Overview

Remote Procedure Calls (RPCs) allow you to call methods on remote peers as if they were local. This is useful for distributed systems where different components need to communicate and perform actions on each other.

## Setting Up RPCs

### Registering RPC Methods

To register a method that can be called remotely, use the `REGISTER_RPC` macro.

```cpp
// Register an RPC method
REGISTER_RPC(MyClass, MyMethod);
```

This method registers two classes :
- `CallMyClassMyMethod`, which can be used to call the method on a remote peer
- `MyClassMyMethodReactor`, which can be used to start listening for remote calls.

### Implementing RPC Methods

Implement the method in your class as you would any other method. The method can take arguments and return a value.

```cpp
class MyClass {
public:
    std::string MyMethod(int arg1, const std::string& arg2) {
        // Method implementation
        return "Result";
    }
};
```

### Subscribing to RPC Methods

To make the method available for remote calls, subscribe to it in your class's initialization code.

```cpp
void MyClass::initRPCService() {
    MyClassMyMethodReactor::subscribe("my_scope", this);
}
```

### Calling RPC Methods

To call a remote method, use the `Call` class generated by the `REGISTER_RPC` macro. You can call the method synchronously or asynchronously.

#### Synchronous Call

```cpp
auto result = CallMyClassMyMethod()
    .on_peer("peer_id")
    .on_fail_log_error()
    .with_timeout(std::chrono::milliseconds(1000))
    .retry(3)
    .call<std::string>(42, "argument");
```

#### Asynchronous Call

```cpp
CallMyClassMyMethod()
    .on_peer("peer_id")
    .on_fail_log_error()
    .with_timeout(std::chrono::milliseconds(1000))
    .retry(3)
    .call_async<std::string>([](const std::string& result) {
        // Handle result
    }, 42, "argument");
```

### Fire-and-Forget Calls

If you do not need a response from the remote method, you can use the fire-and-forget pattern.

```cpp
CallMyClassMyMethod()
    .on_peer("peer_id") // or on_scope for calling on multiple peers
    .on_fail_log_error()
    .fire_and_forget(42, "argument");
```

## Error Handling

You can specify different error handling policies using the `on_fail_do`, `on_fail_log_error`, `on_fail_ignore`, and `on_fail_throw` methods.

### Custom Error Handling

```cpp
CallMyClassMyMethod()
    .on_peer("peer_id")
    .on_fail_do([](CStatus& status) {
        // Custom error handling
    })
    .with_timeout(std::chrono::milliseconds(1000))
    .retry(3)
    .call<std::string>(42, "argument");
```

### Logging Errors

```cpp
CallMyClassMyMethod()
    .on_peer("peer_id")
    .on_fail_log_error()
    .with_timeout(std::chrono::milliseconds(1000))
    .retry(3)
    .call<std::string>(42, "argument");
```

### Ignoring Errors

```cpp
CallMyClassMyMethod()
    .on_peer("peer_id")
    .on_fail_ignore()
    .with_timeout(std::chrono::milliseconds(1000))
    .retry(3)
    .call<std::string>(42, "argument");
```

### Throwing Exceptions

```cpp
CallMyClassMyMethod()
    .on_peer("peer_id")
    .on_fail_throw()
    .with_timeout(std::chrono::milliseconds(1000))
    .retry(3)
    .call<std::string>(42, "argument");
```
