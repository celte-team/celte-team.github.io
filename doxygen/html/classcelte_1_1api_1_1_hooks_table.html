<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Celte: celte::api::HooksTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Celte
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcelte_1_1api_1_1_hooks_table.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classcelte_1_1api_1_1_hooks_table-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">celte::api::HooksTable Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>To allow maximum customization of celte's behaviors, most actions taken by celte can be coupled with user defined hooks.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_celte_hooks_8hpp_source.html">CelteHooks.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a692b2d5612e9cedf3b05416a22cfda90" id="r_a692b2d5612e9cedf3b05416a22cfda90"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a692b2d5612e9cedf3b05416a22cfda90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a692b2d5612e9cedf3b05416a22cfda90">Call</a> (T &amp;&amp;hook, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a692b2d5612e9cedf3b05416a22cfda90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will call the hook if it is not null.  <br /></td></tr>
<tr class="separator:a692b2d5612e9cedf3b05416a22cfda90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa842f00f05ea43a0aedb869a42004bf1" id="r_aa842f00f05ea43a0aedb869a42004bf1"><td class="memItemLeft" ><a id="aa842f00f05ea43a0aedb869a42004bf1" name="aa842f00f05ea43a0aedb869a42004bf1"></a>
struct {&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ab414beb0064573c0a069fc08fe923" id="r_ae3ab414beb0064573c0a069fc08fe923"><td class="memItemLeft" >
&#160;&#160;&#160;struct {&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a2d668e840c6b8b855809477d2d738f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bc29fa76081091eee695fb019c79a0" id="r_aa1bc29fa76081091eee695fb019c79a0"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool()&gt;&#160;&#160;&#160;<a class="el" href="#ad80011c96f93514bf634932faa2a8c8c">onConnectionProcedureInitiated</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:aa1bc29fa76081091eee695fb019c79a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when the server starts trying to reach for the kafka cluster.  <a href="#ad80011c96f93514bf634932faa2a8c8c">More...</a><br /></td></tr>
<tr class="separator:aa1bc29fa76081091eee695fb019c79a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546317f67a36ee63f931ab3f646dc302" id="r_a546317f67a36ee63f931ab3f646dc302"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool()&gt;&#160;&#160;&#160;<b>onConnectionSuccess</b> = []() { return true; }&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a546317f67a36ee63f931ab3f646dc302"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when the server successfully connects to the kafka cluster. <br /></td></tr>
<tr class="separator:a546317f67a36ee63f931ab3f646dc302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc70235f7c7eb4654a7f0d6ba3bb216" id="r_abfc70235f7c7eb4654a7f0d6ba3bb216"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool()&gt;&#160;&#160;&#160;<b>onConnectionError</b> = []() { return true; }&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:abfc70235f7c7eb4654a7f0d6ba3bb216"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when the server fails to connect to the kafka cluster. <br /></td></tr>
<tr class="separator:abfc70235f7c7eb4654a7f0d6ba3bb216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ae15118d0c1da8ad6ed2af72641041" id="r_a98ae15118d0c1da8ad6ed2af72641041"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool()&gt;&#160;&#160;&#160;<b>onServerDisconnected</b> = []() { return true; }&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a98ae15118d0c1da8ad6ed2af72641041"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when the server is disconnected from the kafka cluster for any reason. <br /></td></tr>
<tr class="separator:a98ae15118d0c1da8ad6ed2af72641041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb25dbb8d9e1e43e22cea5fa393f62c" id="r_afdb25dbb8d9e1e43e22cea5fa393f62c"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; std::tuple&lt; std::string, float, float, float &gt;(std::string)&gt;&#160;&#160;&#160;<a class="el" href="#a91edc23abc5f2109a8eb9cde699dc456">onSpawnPositionRequest</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:afdb25dbb8d9e1e43e22cea5fa393f62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when the master receives a new connection and must decide where to redirect the player. The game dev is expected to look up the player's last known position and data, and return it so that it can be forwarded to the server node.  <a href="#a91edc23abc5f2109a8eb9cde699dc456">More...</a><br /></td></tr>
<tr class="separator:afdb25dbb8d9e1e43e22cea5fa393f62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ab414beb0064573c0a069fc08fe923" id="r_ae3ab414beb0064573c0a069fc08fe923"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>connection</b>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ae3ab414beb0064573c0a069fc08fe923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e72d3b438c589439fbea30f111b55" id="r_a9f9e72d3b438c589439fbea30f111b55"><td class="memItemLeft" >
&#160;&#160;&#160;struct {&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a8ffc37ed339f47c97d831378175e6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1696f586c509a238036d01b433e93167" id="r_a1696f586c509a238036d01b433e93167"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool(std::string)&gt;&#160;&#160;&#160;<a class="el" href="#a2d03a3906a41f5fced1561a93bce492f">accept</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a1696f586c509a238036d01b433e93167"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when a new player connects to the server.  <a href="#a2d03a3906a41f5fced1561a93bce492f">More...</a><br /></td></tr>
<tr class="separator:a1696f586c509a238036d01b433e93167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1c4573ceb94c32b01aee063c60eea4" id="r_aba1c4573ceb94c32b01aee063c60eea4"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool(std::string, int, int, int)&gt;&#160;&#160;&#160;<a class="el" href="#a8590b7aa4ac1cc4b9fe2d9c3ec42e14f">execPlayerSpawn</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:aba1c4573ceb94c32b01aee063c60eea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when a new player connects to the server, and must be instantiated in the game world.  <a href="#a8590b7aa4ac1cc4b9fe2d9c3ec42e14f">More...</a><br /></td></tr>
<tr class="separator:aba1c4573ceb94c32b01aee063c60eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e72d3b438c589439fbea30f111b55" id="r_a9f9e72d3b438c589439fbea30f111b55"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>newPlayerConnected</b>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a9f9e72d3b438c589439fbea30f111b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c222438f154a3f5ded26be0997e20b3" id="r_a2c222438f154a3f5ded26be0997e20b3"><td class="memItemLeft" >
&#160;&#160;&#160;struct {&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a15b0a77f1aca36d38210420c319398eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b0d33726b4b25ae66fe67715cdc8c5" id="r_aa3b0d33726b4b25ae66fe67715cdc8c5"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;std::function&lt; bool(std::string)&gt;&#160;&#160;&#160;<a class="el" href="#ae3ca4ed9cde19f4174aa3f79a9fc6854">loadGrape</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:aa3b0d33726b4b25ae66fe67715cdc8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is called when the server is informed that a new grape has been assigned to it.  <a href="#ae3ca4ed9cde19f4174aa3f79a9fc6854">More...</a><br /></td></tr>
<tr class="separator:aa3b0d33726b4b25ae66fe67715cdc8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c222438f154a3f5ded26be0997e20b3" id="r_a2c222438f154a3f5ded26be0997e20b3"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>grape</b>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a2c222438f154a3f5ded26be0997e20b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This collection of hooks regroups all hooks related to managing the lifecycle of a grape, and instantiating it into the game world. <br /></td></tr>
<tr class="separator:a2c222438f154a3f5ded26be0997e20b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa842f00f05ea43a0aedb869a42004bf1" id="r_aa842f00f05ea43a0aedb869a42004bf1"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>server</b>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:aa842f00f05ea43a0aedb869a42004bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>To allow maximum customization of celte's behaviors, most actions taken by celte can be coupled with user defined hooks. </p>
<p>pre_cev should return a boolean which, if false, will prevent the event cev from being processed and abord the procedure. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a692b2d5612e9cedf3b05416a22cfda90" name="a692b2d5612e9cedf3b05416a22cfda90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692b2d5612e9cedf3b05416a22cfda90">&#9670;&#160;</a></span>Call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool celte::api::HooksTable::Call </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>hook</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will call the hook if it is not null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the hook. </td></tr>
    <tr><td class="paramname">Args</td><td>The type of the arguments to pass to the hook </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2d03a3906a41f5fced1561a93bce492f" name="a2d03a3906a41f5fced1561a93bce492f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d03a3906a41f5fced1561a93bce492f">&#9670;&#160;</a></span>accept</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(std::string)&gt; celte::api::HooksTable::accept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](std::string clientId) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      }</div>
</div><!-- fragment -->
<p>This hook is called when a new player connects to the server. </p>

</div>
</div>
<a id="a8590b7aa4ac1cc4b9fe2d9c3ec42e14f" name="a8590b7aa4ac1cc4b9fe2d9c3ec42e14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8590b7aa4ac1cc4b9fe2d9c3ec42e14f">&#9670;&#160;</a></span>execPlayerSpawn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(std::string, int, int, int)&gt; celte::api::HooksTable::execPlayerSpawn</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          [](std::string clientId, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
</div><!-- fragment -->
<p>This hook is called when a new player connects to the server, and must be instantiated in the game world. </p>

</div>
</div>
<a id="ae3ca4ed9cde19f4174aa3f79a9fc6854" name="ae3ca4ed9cde19f4174aa3f79a9fc6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ca4ed9cde19f4174aa3f79a9fc6854">&#9670;&#160;</a></span>loadGrape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(std::string)&gt; celte::api::HooksTable::loadGrape</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](std::string grapeId) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      }</div>
</div><!-- fragment -->
<p>This hook is called when the server is informed that a new grape has been assigned to it. </p>

</div>
</div>
<a id="ad80011c96f93514bf634932faa2a8c8c" name="ad80011c96f93514bf634932faa2a8c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80011c96f93514bf634932faa2a8c8c">&#9670;&#160;</a></span>onConnectionProcedureInitiated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool()&gt; celte::api::HooksTable::onConnectionProcedureInitiated</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      }</div>
</div><!-- fragment -->
<p>This hook is called when the server starts trying to reach for the kafka cluster. </p>

</div>
</div>
<a id="a91edc23abc5f2109a8eb9cde699dc456" name="a91edc23abc5f2109a8eb9cde699dc456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91edc23abc5f2109a8eb9cde699dc456">&#9670;&#160;</a></span>onSpawnPositionRequest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::tuple&lt;std::string, float, float, float&gt;(std::string)&gt; celte::api::HooksTable::onSpawnPositionRequest</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](std::string clientId) {</div>
<div class="line">            <span class="keywordflow">return</span> std::make_tuple(</div>
<div class="line">                <span class="stringliteral">&quot;hook onSpawnPositionRequest not implemented&quot;</span>, 0, 0, 0);</div>
<div class="line">          }</div>
</div><!-- fragment -->
<p>This hook is called when the master receives a new connection and must decide where to redirect the player. The game dev is expected to look up the player's last known position and data, and return it so that it can be forwarded to the server node. </p>
<p>The hook is called by the impolementation of celte::server::states::Connected::__rp_getPlayerSpawnPosition.</p>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the grape id, the x, y, z coordinates of the spawn for the client that has been requested </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>runtime/include/<a class="el" href="_celte_hooks_8hpp_source.html">CelteHooks.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>celte</b></li><li class="navelem"><b>api</b></li><li class="navelem"><a class="el" href="classcelte_1_1api_1_1_hooks_table.html">HooksTable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
